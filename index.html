<!DOCTYPE html>
<html>
<head>
    <title>The BeavisHead Game</title>
    <style type="text/css">
        body, html {
            text-align: center;
            width:100%;
            height:100%;
            margin : 0;
        }

    </style>

    <script>
    var ctx;
    var c;
    var fps;
    var render_interval;
    var keys;
    var world;
    var assets;
    var events = {};
    var frame = 0; // Current frame
    var gg = false;

    function load_assets() {
        var end_screen = new Image();
        var grass_tile = new Image();
        var player_mdl_idle = new Image();
        var player_mdl_hit = new Image();
        var honzeek_mdl_idle = new Image();
        var honzeek_mdl_hit = new Image();
        end_screen.src = "https://cdn.discordapp.com/attachments/788804003315449857/1005542893609558107/end.png";
        grass_tile.src = "https://cdn.discordapp.com/attachments/749608248184799345/1005129290582609960/unknown.png";
        player_mdl_idle.src = "https://cdn.discordapp.com/emojis/980168035082055690.webp";
        player_mdl_hit.src = "https://cdn.discordapp.com/emojis/980168035082055690.webp";
        honzeek_mdl_idle.src = "https://cdn.discordapp.com/emojis/857700195689300008.webp";
        honzeek_mdl_hit.src = "https://cdn.discordapp.com/attachments/749608248184799345/1004827766283309126/honzeek_hit.webp";
        return {
            'hud' : {
                'end_screen' : end_screen,
            },
            'tiles' : {
                'grass' : grass_tile,
            },
            'player' : {
                'model_idle' : player_mdl_idle,
                'model_hit' : player_mdl_hit,
            },
            'honzeek' : {
                'model_idle' : honzeek_mdl_idle,
                'model_hit' : honzeek_mdl_hit,
            },
        }
    }
    
    function _make_text(x,y,message, type, color) {
        // For tooltip texts etc.
        var text = {
            'origin' : {'x' : x, 'y' : y},
            'velocity' : {'x' : 0, 'y' : 0},
            'color' : color,
            'alpha' : 1.0,
            'size' : 20,
            'message' : message,
            'type' : type,
            'hp' : 0
        }

        if (type == 0) {
            // Static text
            text.hp = 300; // 5 seconds
        }
        if (type == 1) {
            // Flying damage number
            text.hp = 60; // half a second
            text.size = 120;
            text.velocity.x = 0.0;
            text.velocity.y = -2;
        }

        return text
    }

    function generate_monster_event(type) {
        // Generate monster
        var monster;
        if (type == 0) {
            monster = _make_honzeek()
        }
        world.entities.push(monster);
        world.monsters.push(monster);
        // Plan next
        make_event(frame + 30, generate_monster_event, [type]);
    }

    function _make_honzeek() {
        var player = world.player;
        var x_off = Math.random()-0.5;
        var y_off = Math.random()-0.5;
        var dist = Math.sqrt(x_off**2 + y_off**2);
        x_off = x_off / dist;
        y_off = y_off / dist;
        var x = player.origin.x + 1000*x_off;
        var y = player.origin.y + 1000*y_off;
        return {
            'origin' : {'x' : x, 'y' : y},
            'color' : "#999999",
            'size' : 60,
            'model' : undefined,
            'model_idle' : assets.honzeek.model_idle,
            'model_hit' : assets.honzeek.model_hit,
            'hit_recently' : false,
            'isMonster' : true,
            'max_hp' : 300,
            'hp' : 300,
            'damage' : 10,
            'speed' : 4
        }
    }


    function add_listeners() {
        c.addEventListener('mousemove', function(evt) {
            var rect = c.getBoundingClientRect();
            keys.mouse_x = evt.clientX - rect.left;
            keys.mouse_y = evt.clientY - rect.top;
        });
        c.addEventListener('mousedown', function(evt) {
            if (evt.button == 0) {
                if (keys.mouse1 == false) {
                    keys.mouse1first = true; // first frame of holding mouse, set this flag
                }
                keys.mouse1 = true;
            }
        });
        c.addEventListener('mouseup', function(evt) {
            if (evt.button == 0) {
                keys.mouse1 = false;
                keys.mouse1first = false;
            }
        });
        document.addEventListener('keydown', function(evt) {
            if (evt.defaultPrevented) {
                return;
            }
            if (evt.code === "KeyS"){
                keys.down = true;
            } else if (evt.code === "KeyW"){
                keys.up = true;
            } else if (evt.code === "KeyA"){
                keys.left = true;
            } else if (evt.code === "KeyD"){
                keys.right = true;
            }
        });
        document.addEventListener('keyup', function(evt) {
            if (evt.defaultPrevented) {
                return;
            }
            if (evt.code === "KeyS"){
                keys.down = false;
            } else if (evt.code === "KeyW"){
                keys.up = false;
            } else if (evt.code === "KeyA"){
                keys.left = false;
            } else if (evt.code === "KeyD"){
                keys.right = false;
            }
        });
    }

    function _make_projectile(spread, speed) {
        var player = world.player;
        var rand_angle = (Math.random() - 0.5) * spread;
        var vel_x = Math.cos(rand_angle) * player.angle.x - Math.sin(rand_angle) * player.angle.y;
        var vel_y = Math.sin(rand_angle) * player.angle.x + Math.cos(rand_angle) * player.angle.y;
        return {
            "origin" : {"x" : player.origin.x + player.angle.x*30, "y" : player.origin.y + player.angle.y*30},
            "velocity" : {"x" : vel_x*speed, "y" : vel_y*speed},
            "size" : 7,
            "color" : "#FFFFFF",
            "hp" : 60,
            "damage" : Math.floor(Math.random() * 20)+40,
        }
    }

    function perform_attack(count) {
        // Generate several projectiles
        for (var i = 0; i < count; i++) {
            var _proj = _make_projectile(0.6, 20);
            world.entities.push(_proj);
            world.projectiles.push(_proj);
        }    
    }

    function collisions() {

        // Projectile vs monster collision
        for (var i = 0; i < world.monsters.length; i++) {          
            var monster_x = world.monsters[i].origin.x;
            var monster_y = world.monsters[i].origin.y;
            var monster_size = world.monsters[i].size * 0.4; // Hitbox a bit smaller
            // Monster can be hit by multiple projs per frame
            for (var j = 0; j < world.projectiles.length; j++) {    
                var proj_x = world.projectiles[j].origin.x;
                var proj_y = world.projectiles[j].origin.y;
                var proj_size = world.projectiles[j].size;
                var dist = Math.sqrt((monster_x-proj_x)**2 + (monster_y-proj_y)**2);
                // Collision?
                if (dist < monster_size + proj_size) {
                    // Kill projectile and damage monster
                    world.projectiles[j].hp = 0;
                    world.monsters[i].hp -= world.projectiles[j].damage;
                    world.monsters[i].hit_recently = true;
                    console.log(world.projectiles[j].damage);
                    var text = _make_text(monster_x, monster_y, world.projectiles[j].damage, 1, "#FFFFFF");
                    world.texts.push(text);
                    world.entities.push(text);
                }
            }
        }

        // Player vs monster collision
        var player = world.player;
        for (var i = 0; i < world.monsters.length; i++) {
            var monster_x = world.monsters[i].origin.x;
            var monster_y = world.monsters[i].origin.y;
            var monster_size = world.monsters[i].size * 0.4; // Hitbox a bit smaller
            var player_x = player.origin.x;
            var player_y = player.origin.y;
            var player_size = player.size;
            var dist = Math.sqrt((player_x-monster_x)**2 + (player_y-monster_y)**2);
            if (dist < player_size + monster_size) {
                // Monster explodes and deals damage to player
                player.hp -= world.monsters[i].damage;
                world.monsters[i].hp = 0;
                var text = _make_text(player.origin.x, player.origin.y, world.monsters[i].damage, 1, "#FF0000");
                world.texts.push(text);
                world.entities.push(text);
            }
        }

    }

    function update_world_texts() {
        world.texts.forEach( (text) => {
            text.hp -= 1;
            text.origin.x += text.velocity.x;
            text.origin.y += text.velocity.y;
            text.velocity.x *= 0.97;
            text.velocity.y *= 0.97;
            text.size *= 0.92;
            text.alpha = text.alpha**1.3 - 0.001;
            text.alpha = text.alpha < 0.1 ? 0.1 : text.alpha;
        });
    }

    function update_projectiles() {
        world.projectiles.forEach( (projectile) => {
            projectile.hp -= 1;
            projectile.origin.x += projectile.velocity.x;
            projectile.origin.y += projectile.velocity.y;
        })
    }

    function update_monsters() {
        var player = world.player;
        world.monsters.forEach( (monster) => {
            if (monster.hit_recently == true) {
                monster.model = monster.model_hit;
                monster.hit_recently = false;
            }
            else {
                monster.model = monster.model_idle;
            }
            // Follow player
            var dx = monster.origin.x - player.origin.x;
            var dy = monster.origin.y - player.origin.y;
            var dist = Math.sqrt(dx**2 + dy**2);
            dx /= dist;
            dy /= dist;
            monster.origin.x += -dx*monster.speed;
            monster.origin.y += -dy*monster.speed;
            
        })
    }

    function postthink() {
        // Check if player died this frame
        if (world.player.hp <= 0) {
            gg = true;
            world.player.hp = 0;
        }

        // Remove dead projectiles
        world.projectiles = world.projectiles.filter(function(ent) {
            return ent.hp > 0;
        });

        // Remove dead monsters
        world.monsters = world.monsters.filter(function(ent) {
            return ent.hp > 0;
        });

        // Remove dead text messages
        world.texts = world.texts.filter(function(ent) {
            return ent.hp > 0;
        });

        // Remove all dead entities
        world.entities = world.entities.filter(function(ent) {
            if (ent.hp != undefined) {
                return ent.hp > 0;
            }
            return true;  
        });
    }

    function update_camera() {
        // Just snap it to player origin
        var camera = world.camera;
        var player = world.player;
        camera.origin.x = player.origin.x;
        camera.origin.y = player.origin.y;
    }

    function update_player() {
        // Update player state using current controls
        var player = world.player;
        var crosshair = player.crosshair;
        var mouse_dx = keys.mouse_x - ctx.canvas.width/2;
        var mouse_dy = keys.mouse_y - ctx.canvas.height/2;
        var mouse_dist = Math.sqrt(mouse_dx*mouse_dx + mouse_dy*mouse_dy);
        player.angle.x = mouse_dx/mouse_dist;
        player.angle.y = mouse_dy/mouse_dist;
        if (keys.up) {
            player.origin.y -= player.movement_speed;
        }
        if (keys.down) {
            player.origin.y += player.movement_speed;
        }
        if (keys.left) {
            player.origin.x -= player.movement_speed;
        }
        if (keys.right) {
            player.origin.x += player.movement_speed;
        }
        if (keys.mouse1first) {
            keys.mouse1first = false;
            perform_attack(5);
        }
        player.model = player.model_idle;
        crosshair.origin.x = player.origin.x + player.angle.x * 32;
        crosshair.origin.y = player.origin.y + player.angle.y * 32;
    }


    function __init_crosshair() {
        return {
            'origin' : {'x' : 0, 'y' : 0},
            'color' : "#FF0000",
            'size' : 4
        }
    }

    function __init_player() {
        var crosshair = __init_crosshair();
        return {
            'origin' : {'x' : 0, 'y' : 0},
            'angle' : {'x' : 1, 'y' : 0},
            'crosshair' : crosshair,
            'movement_speed' : 4,
            'model_active' : undefined,
            'model_idle' : assets.player.model_idle,
            'model_hit' : assets.player.model_hit,
            'color' : "#008800",
            'size' : 60,
            'max_hp' : 100,
            'hp' : 100,
        }
    }

    function __init_world() {
        var player = __init_player();
        var camera = __init_camera();
        var world = {
            'mapsize' : {'x' : 500, 'y' : 500},
            'player' : player,
            'camera' : camera,
            'entities' : [player, player.crosshair],
            'monsters' : [],
            'projectiles' : [],
            'texts' : []
        };
        return world;
    }

    function __init_camera() {
        return {
            'origin' : {'x' : 0, 'y' : 0},
        }
    }

    function __init_keys() {
        return {
            "left" : false,
            "up" : false,
            "right" : false,
            "down" : false,
            "mouse_x" : 0,
            "mouse_y" : 0,
            "mouse1" : false,
            "mouse1first" : false
        }
    }

    function make_event(time, callback, params) {
        var ev = {'f' : callback, 'params' : params};
        if (events[time] == undefined) {
            events[time] = [ev];
        }
        else {
            events[time].push(ev);
        }
    }

    function check_event() {
        // Check if something should happen at current frame
        var current_events = events[frame];
        if (current_events != undefined) {
            // Call all events
            for (var i = current_events.length - 1; i >= 0; i--) {

                current_events[i].f(...current_events[i].params);
            }
            delete events[frame];
        }
    }

    function init_game() {
        c = document.getElementById('area');
        ctx = c.getContext('2d');
        ctx.canvas.width  = window.innerWidth-4;
        ctx.canvas.height = window.innerHeight-4;
        fps = 60;
        
        assets = load_assets();
        world = __init_world();
        keys = __init_keys();
        
        make_event(100, generate_monster_event, [0]);

        add_listeners();

        render_interval = window.setInterval(simloop, 1000/fps);
    }

    function prethink() {
        update_player();
        update_camera();
        update_monsters();
        update_projectiles();
        update_world_texts();
    }


    // Main game loop
    function simloop() {
        check_event();
        prethink();
        collisions();
        postthink();

        if (gg) {
            // Something triggered game over this frame
            // next draw will be final and game loop stops
            clearInterval(render_interval);
        }

        draw();

        frame += 1;    
    }

    function draw_background() {
        // This thing is super hacky and shitty
        var camera = world.camera;
        var off_x = camera.origin.x-ctx.canvas.width/2;
        var start_x = off_x - off_x%128;
        var end_x = start_x + ctx.canvas.width;
        var off_y = camera.origin.y-ctx.canvas.height/2;
        var start_y = off_y - off_y%128;
        var end_y = start_y + ctx.canvas.height;
        for (var i = start_x - 128; i <= end_x + 128; i += 128) {
            for (var j = start_y - 128; j <= end_y + 128; j += 128) {
                ctx.drawImage(assets.tiles.grass, 
                    ctx.canvas.width/2  - camera.origin.x + i, 
                    ctx.canvas.height/2 - camera.origin.y + j,
                    129, 129 // 129 because 128 looked bad
                );
            }
        }

    }

    function draw_hud() {   
        // Draw player HP
        var player = world.player;
        ctx.font = '60px serif';
                    ctx.fillStyle = "#FF0000";
                    ctx.fillText("♥" + player.hp, 
                        30,  ctx.canvas.height - 30
                        );
        if (gg) {
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = "#000000";
            ctx.fillRect(
                0, 
                0, 
                ctx.canvas.width, ctx.canvas.height
            );
            ctx.globalAlpha = 1.0;

            ctx.drawImage(assets.hud.end_screen, 
                ctx.canvas.width/2  - 128, 
                ctx.canvas.height/2  - 128,
                256, 256
            );
        }
    }

    function draw() {

        var camera = world.camera;

        draw_background();

        // draw_entities
        world.entities.forEach( (ent) => {
            if (ent.model) {
                ctx.drawImage(ent.model, 
                    ctx.canvas.width/2  - camera.origin.x + ent.origin.x-ent.size/2, 
                    ctx.canvas.height/2 - camera.origin.y + ent.origin.y-ent.size/2,
                    ent.size, ent.size
                );
            }
            else if (ent.message) {
                if (ent.type == 1) {
                    ctx.font = (ent.size+15) + 'px serif';
                    ctx.fillStyle = ent.color;
                    ctx.globalAlpha = ent.alpha;
                    ctx.fillText(ent.message, 
                        ctx.canvas.width/2  - camera.origin.x + ent.origin.x, 
                        ctx.canvas.height/2 - camera.origin.y + ent.origin.y);
                    ctx.globalAlpha = 1.0;
                }
                else {
                    ctx.font = ent.size + 'px serif';
                    ctx.fillStyle = ent.color;
                    ctx.fillText(ent.message, 
                        ctx.canvas.width/2  - camera.origin.x + ent.origin.x, 
                        ctx.canvas.height/2 - camera.origin.y + ent.origin.y);
                }

            }
            else {
                ctx.fillStyle = ent.color;
                ctx.fillRect(
                    ctx.canvas.width/2  - camera.origin.x + ent.origin.x, 
                    ctx.canvas.height/2 - camera.origin.y + ent.origin.y, 
                    ent.size, ent.size);
            }       
        })

        draw_hud();

    }
    </script>

</head>
<body onload="init_game()">
<canvas id="area"></canvas>
</body>


</html>
